---
title: "[운영체제 아주 쉬운 세 가지 이야기 - Virtualization] 10. Multi-CPU Scheduling"
writer: Langerak
date: 2025-07-08 13:00:00 +0800
categories: [Computer Science, Operating System]
tags: [Operating System]
pin: false
math: true
mermaid: true
image:
  path: assets/img/thumbnails/ostep.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: Operating System
---

> 이 글은 제 개인적인 공부를 위해 작성한 글입니다.   
> 틀린 내용이 있을 수 있고, 피드백은 환영합니다.

<br/>

### 개요

---

이 장에서는 **멀티프로세서 스케줄링(multiprocessor scheduling)**의 기본을 소개한다.
이 주제는 어느정도 기초를 벗어났기에 병행성(concurrency)에 대한 이해가 필요하다.

고사양 컴퓨터에만 존재했던 **멀티프로세서(multiprocessor)** 시스템은 일반적이게 되었으며, 컴퓨터, 노트북, 모바일 장치에도 사용되고 있다.
여러 개의 CPU 코어가 하나의 칩에 내장된 **멀티코어(multicore)** 프로세서가 대중화의 근본 원인이다.
싱글코어 CPU의 성능 개선이 한계에 봉착하면서 멀티코어 기술이 각광을 받게되었고 우리는 다수의 CPU를 사용할 수 있게 되었다.

다중 CPU 시대가 오면서 많은 문제가 발생하였다.
가장 중요한 것은 전통적인 응용 프로그램은 오직 하나의 CPU만 사용한다는 것이다.
더 많은 CPU를 추가해도 더 빨리 실행되지 않는다.
이 문제를 해결하려면 응용 프로그램을 **쓰레드**를 이용하여 **병렬(parallel)**로 실행되도록 다시 작성해야 한다.
멀티 쓰레드 응용 프로그램은 작업을 여러 CPU에 할당하며, 따라서 더 많은 수의 CPU가 주어지면 더 빠르게 실행된다.

응용 프로그램뿐 아니라 운영체제가 새로이 직면한 문제는 멀티프로세서서 스케줄링이다.
지금까지 우리는 단일프로세서 스케줄링의 많은 원칙들에 대해 논의하였다.
이 아이디어를 여러 CPU에서 동작하도록 어떻게 확장할 수 있을까?

<br/>

### 배경 : 멀티프로세서 구조

---

멀티프로세서 스케줄링에 대한 새로운 문제점을 이해하기 위해서는 단일 CPU 하드웨어와 멀티 CPU 하드웨어의 근본적인 차이에 대한 이해가 필요하다.
다수의 프로세서 간에 데이터의 공유, 그리고 하드웨어 **캐시**의 사용 방식에서 근본적인 차이가 발생한다.
여기서는 이 문제를 개념적으로만 다루도록 한다.

단일 CPU 시스템에는 프로그램을 빠르게 실행하기 위한 **하드웨어 캐시** 계층이 존재한다.
캐시는 메인 메모리에서 자주 사용되는 데이터의 복사본을 저장하는 작고 빠른 메모리이다.
메인 메모리는 모든 데이터를 저장하지만 느리다.
자주 접근되는 데이터를 캐시에 임시로 가져다 둠으로써 시스템은 크고 느린 메모리를 빠른 메모리처럼 보이게 한다.

![img](https://1drv.ms/i/c/0feb846c92fbe54a/IQTkYjUiBUHMTqcxDLYnQ0WJAVCzjajOY7DefbjpddEUHG0?width=361&height=327)

예를 들어, load 명령어를 수행하는 프로그램과 하나의 CPU만 있는 간단한 시스템을 생각해보자.
CPU는 작은 크기의 캐시와 큰 메인 메모리를 갖고 있다.

프로그램이 처음 이 load 명령어를 실행할 때, 데이터가 메인 메모리에 존재하므로 데이터를 가져오는 데 긴 시간이 소모된다.
데이터가 다시 사용될 것으로 예상한 프로세서는 읽은 데이터의 복사본을 CPU 캐시에 저장한다.
프로그램이 나중에 다시 같은 데이터를 가져오려고 하면, CPU는 우선 해당 데이터가 캐시에 존재하는지 검사한다.
캐시에 존재하기 때문에 데이터는 훨씬 빨리 접근되고 프로그램은 빨리 실행한다.

캐시는 **지역성(locality)**에 기반한다.
지역성에는 **시간 지역성(temporal locality)**과 **공간 지역성(spatial locality)**의 두 종류가 있다.
시간 지역성의 기본 아이디어는 데이터가 한번 접근되면 가까운 미래에 다시 접근되기 쉽다는 것이다.
루프에서 여러 번 반복해서 접근되는 변수 또는 명령어 자체를 생각해보면 이해하기 쉽다.
공간 지역성의 기본 아이디어는 프로그램이 주소 x의 데이터를 접근하면 x 주변의 데이터가 접근되기 쉽다는 것이다.
전체 배열에 차례대로 접근하는 프로그램을 생각하면 이해하기 쉽다.

![img](https://1drv.ms/i/c/0feb846c92fbe54a/IQT2IqjwmeZTTZYIpHtHCrIhAVs3jRnV3fv3rEEWvZUrEos?width=522&height=304)

그렇다면 위 사진처럼 하나의 시스템에 여러 프로세서가 존재하고 하나의 공유 메인 메모리가 있을 때 어떤 일이 일어나는가?

멀티프로세서 시스템에서 캐시를 사용하는 것은 훨씬 복잡하다.
예를 들어, CPU 1에서 실행 중인 프로그램이 주소 A를 읽어 값 D을 가져온다고 해보자.
데이터가 CPU 1 캐시에 존재하지 않기 때문에 시스템은 메인 메모리로부터 데이터를 가져오고 값 D를 얻는다.
그런 후 프로그램은 주소 A의 값을 변경한다.
변경은 캐시에 존재하는 값만 D`으로 갱신한다.
메모리에 데이터를 쓰는 것은 시간이 오래 걸리므로 메인 메모리에 기록하는 것은 보통 나중에 한다.

운영체제가 프로그램의 실행을 중단하고 CPU 2로 이동하기로 결정한다고 해보자.
프로그램은 주소 A의 값을 다시 읽는다.
CPU 2의 캐시에는 주소 A의 값이 존재하지 않기에 시스템은 메인 메모리에서 D`이 아닌 옛날 값인 D를 가져온다.

이 문제를 **캐시 일관성 문제(cache coherence)**라고 부른다.

기본적인 해결책은 하드웨어에 의해 제공된다.
하드웨어는 메모리 주소를 계속 감시하고, 항상 제대로 된 상황만 발생토록 시스템을 관리한다.
특히, 여러 개의 프로세서들이 하나의 메모리에 갱신할 떄에는 항상 공유되도록 한다.
버스 기반 시스템에서는 **버스 스누핑(bus snooping)**이라는 오래된 기법을 사용한다.
캐시는 자신과 메모리를 연결하는 버스의 통신 상황을 계속 모니터링하고, 캐시 데이터에 대한 변경이 발생하면, 
자신의 복사본을 자신의 캐시에서 삭제하는 **무효화(invalidate)**를 시키거나 새로운 값을 캐시에 기록하는 갱신을 한다.

나중 쓰기(write-back) 캐시는 메인 메모리에 쓰기 연산이 지연되기 때문에 캐시 일관선 유지 문제를 훨씬 복잡하게 만든다.

<br/>

### 동기화 문제

---

일관성 유지에 대한 모든 일을 캐시가 담당한다면, 프로그램 또는 운영체제 자신은 공유 데이터를 접근할 때 걱정할 필요가 있을까?
불행하게도 대답은 예 이다.

CPU들이 동일한 데이터 또는 구조체에 접근할 때, 올바른 연산 결과를 보장하기 위해 락 같은 상호 배제를 보장하는 동기화 기법이 많이 사용된다.
**락-프리(lock-free)** 데이터 구조 등의 다른 방식은 복잡할 뿐 아니라 특별한 경우에만 사용된다.

예를 들어, 여러 CPU가 동시에 사용하는 공유 큐가 있다고 가정하자.
캐시의 일관성을 보장하는 프로토콜이 존재한다 하더라도 락 없이는 항목의 추가나 삭제가 제대로 동작하지 않을 것이다.
구조체를 원자적으로 갱신하기 위해서는 락이 필요하다.

![img](https://1drv.ms/i/c/0feb846c92fbe54a/IQRBXg8b_JLWSobh05psgQOrAQ6mDEr4h-giYSrzZtWLuVQ?width=660)

연결 리스트에서 원소 하나를 삭제한다고 예시를 들어보자.
두 CPU의 쓰레드가 동시에 이 루틴에 진입한다면,
각 쓰레드는 자신만의 스택을 가지고 있기에 각 쓰레드는 동일한 헤드 원소를 제거하려고 한다.
각 쓰레드는 리스트의 첫 번째 원소를 한 번씩 제거하는데,
이러한 상황이 원소를 두 번 삭제하고 같은 데이터 값을 두 번 반환하는 등의 문제를 야기한다.

물론 해결책은 **락(lock)**을 사용하여 올바르게 동작하도록 만드는 것이다.
간단한 뮤텍스를 할당하여 문제를 해결할 수 있지만, 성능 측면에서 CPU의 개수가 증가할 수록 동기화된 자료 구조에 접근하는 연산은 매우 느리게 된다.

<br/>

### 캐시 친화성 문제

---

멀티프로세서 캐시 스케줄러에서의 마지막 문제점은 **캐시 친화성(cache affinity)**이다.
개념은 간단한데, CPU에서 실행될 때 프로세스는 해당 CPU 캐시와 TLB에 상당한 양의 상태 정보를 올려 놓게 된다.
해당 CPU 캐시에 일부 정보가 이미 존재하고 있으니,
다음 번에 프로세스가 실행될 때 동일한 CPU에서 더 빨리 실행될 수 있다.

반면 프로세스가 매번 다른 CPU에서 실행되면 실행할 때마다 필요한 정보를 캐시에 다시 탑재해야만 하기 떄문에 프로세스의 성능은 더 나빠질 것이다.
하드웨어의 캐시 일관성 프로토콜 덕분에 다른 CPU에서 실행되더라도 프로그램은 제대로 실행될 것이다.

멀티프로세서 스케줄링은 스케줄링 결정을 내릴 때 캐시 친화성을 고려해야 한다.
가능한 한 프로세스를 동일한 CPU에서 실행하려고 노력하는 방향으로 스케줄링을 결정해야 되는 것이다.

<br/>

### 단일 큐 멀티프로세서 스케줄링 : SQMS

---

이제 멀티프로세서 시스템의 스케줄러 개발 방법에 대해 이야기해보자.

가장 기본적인 방식은 단일 프로세서 스케줄링의 기본 프레임워크를 그대로 사용하는 것이다.
이러한 방식을 **단일 큐 멀티프로세서 스케줄링(single queue multiprocessor scheduling, SQMS)**이라고 부르낟.

이 방식의 장점은 단순함이다. 기존 정책을 다수의 CPU에서 동작하도록 하는 데는 많은 변경이 필요하지 않다.
예를 들어, CPU가 2개라면 실행할 작업 두 개를 선택한다.

그러나 SQMS는 명백한 단점이 있다.
첫 번째 문제는 **확장성(scalability)**의 결여이다.
스케줄러가 다수의 CPU에서 제대로 동작하게 하기 위해 코드에 일정 형태의 **락**을 삽입한다.
락은 SQMS 코드가 실행시킬 다음 작업을 찾기 위해 단일 큐에 접근할 때 올바른 결과가 나오도록 한다.

불행하게도 락은 성능을 크게 저하시킬 수 있고, 시스템의 CPU 개수가 증가할수록 더욱 그렇다.
단일 락에 대한 경쟁이 증가할수록 시스템은 락에 점점 더 많은 시간을 소모하게 되고 실제 필요한 일에 쓰는 시간은 줄어들게 된다.

두 번째 문제는 **캐시 친화성**이다.
예를 들어, 실행할 5개의 작업이 있고 4개의 프로세서가 있다고 가정하자.
스케줄링 큐는 A->B->C->D->E의 모습일 것이다.

시간이 흐르면서 각 작업은 주어진 타임 슬라이스 동안 실행되고, 다음 작업이 선택되었다고 가정하자.
작업 스케줄은 다음과 같을 것이다.

- CPU 0 : A -> E -> D -> C -> B ... 반복
- CPU 1 : B -> A -> E -> D -> C ... 반복
- CPU 2 : C -> B -> A -> E -> D ... 반복
- CPU 3 : D -> C -> B -> A -> E ... 반복

각 CPU는 공유 큐에서 다음 작업을 선택하기 때문에 각 작업은 CPU를 옮겨 다니게 된다.
캐시 친화성 관점에서 보면 잘못된 선택을 하는 것이다.

이 문제의 해결을 위해 대부분의 SQMS 스케줄러는 특정 작업들에 대해서 캐시 친화성을 고려하여 스케줄링하고 다른 작업들은 오버헤드를 균등하게 하기 위해 여러 군데로 분산시키는 정책을 사용하여
가능한 한 프로세스가 동일한 CPU에서 재실행될 수 있도록 한다.

- CPU 0 : A -> E -> A -> A -> A ... 반복
- CPU 1 : B -> B -> E- > B -> B ... 반복
- CPU 2 : C -> C -> C -> E -> C ... 반복
- CPU 3 : D -> D -> D -> D -> E ... 반복

이 배열에서 A부터 D까지의 작업은 각각 자신의 프로세서에서 실행되고, E만이 하나의 프로세서에서 다른 프로세서로 이동한다.
이렇게 함으로써 대부분의 작업에게 캐시 친화성을 보장하지만 구현이 복잡해질 수 있다.

SQMS는 하나의 큐 밖에 없기에 구현이 간단하지만 동기화 오버헤드 때문에 확장성이 좋지 않고 캐시 친화성에 문제가 있다.

<br/>

### 멀티 큐 멀티프로세서 스케줄링 : MQMS

---

단일 큐 스케줄러로 인한 문제 때문에 일부 시스템은 CPU마다 큐를 하나씩 두는 **멀티 큐 멀티프로세서 스케줄링(multi-queue multiprocessor scheduling, MQMS)**을 사용한다.

MQMS에서 기본적인 스케줄링 프레임워크는 여러 개의 스케줄링 큐로 구성된다.
각 큐는 라운드 로빈 같은 특정 스케줄링 정책을 따르고, 어떤 스케줄링 기법도 사용 가능하다.

작업이 시스템에 들어가면 하나의 스케줄링 큐에 배치된다.
배치될 큐의 결정은 무작위로 할 수도 있고, 다른 큐보다 작은 수의 작업이 있는 큐로 배치할 수도 있다.
그 후에는 각각 독립적으로 스케줄 되기 때문에 단일 큐 방식에서 보았던 정보의 공유 및 동기화 문제는 피할 수 있다.

예를 들어 CPU 0과 CPU 1 두 개의 CPU와 A, B, C, D 네 개의 작업이 시스템에 있다고 해보자.
CPU는 각자 하나의 스케줄링 큐를 가지고 있으므로 운영체제는 각 작업에 배치할 큐를 결정해야 한다.

- Q0 : A -> C
- Q1 : B -> D

큐 스케줄링 정책에 따라 각 CPU는 현재 2개씩의 작업을 가지고 있고, 라운드 로빈의 경우 다음과 같은 스케줄이 생성될 수 있다.

- CPU 0 : A -> A -> C -> C -> A -> A ... 반복
- CPU 1 : B -> B -> D -> D -> B -> B ... 반복

MQMS가 SQMS에 비해 가지는 명확한 이점은 확장성이 좋다는 것이다.
CPU 개수가 증가할수록, 큐의 개수도 증가하므로 락과 캐시 경합은 더 이상 문제가 되지 않는다.
또한, MQMS는 작업이 같은 CPU에서 계속 실행되기 때문에 본질적으로 캐시 친화적이다.

하지만 MQMS의 근본적인 문제는 **워크로드의 불균형(load imbalance)**이다.
앞의 예와 동일한 가정을 하되, C가 종료되었다면 다음과 같은 스케줄링 큐를 가진다.

- Q0 : A
- Q1 : B -> D

그리고 라운드 로빈 정책일 때 다음과 같은 스케줄을 얻을 수 있다.

- CPU 0 : A -> A -> A -> A -> A -> A ... 반복
- CPU 1 : B -> B -> D -> D -> B -> B ... 반복

A가 B와 D보다 2배의 CPU를 차지하고 있는 모습은 우리가 원하는 결과가 아니다.
만약 A까지 종료되어 B와 D만 남는다면 CPU 0은 유휴 상태가 되는 결과를 얻게 될 것이다.

우리는 이 문제를 해결하기 위해 **이주(migration)**를 사용한다.
작업을 한 CPU에서 다른 CPU로 이주시킴으로써 워크로드 균형을 달성한다.

몇 가지 예를 살펴보도록 하자.

- Q0 : 
- Q1 : B -> D

이 경우에 운영체제는 B, D 중 하나를 CPU 0으로 이주시켜 워크로드의 균형을 맞출 수 있다.

- Q0 : A
- Q1 : B -> D

이 경우에는 한 번의 이주만으로는 문제가 해결되지 않는다.
한 가지 가능한 해결책은 다음 타임라인에서 볼 수 있는 것처럼 계속해서 작업을 이주하여 워크로드의 균형을 맞추는 것이다.

- CPU 0 : A -> A -> A -> A -> B -> A -> B -> A -> B -> B -> B -> B -> ...
- CPU 1 : B -> D -> B -> D -> D -> D -> D -> D -> A -> D -> A -> D -> ... 

물론 가능한 많은 이주 패턴이 존재한다.
그렇다면 어떻게 이주의 필요 여부를 결정할 수 있을까?
한 가지 기본적인 접근 방식은 **작업 훔치기(work stealing)**라는 기술이다.
작업 훔치기에는 작업의 개수가 낮은 큐가 가끔 다른 큐에 훨씬 많은 수의 작업이 있는지를 검사한다.
대상 큐가 소스 큐보다 더 가득 차있다면 워크로드의 균형을 맞추기 위해 소스는 대상에서 하나 이상의 작업을 가져온다.

물론 이러한 방식에서는 큐를 너무 자주 검사하게 되면 높은 오버헤드로 확장성에 문제가 생기게 된다.
확장성은 MQMS의 가장 중요한 목적이다.
반면 다른 큐를 자주 검사하지 않으면 심각한 워크로드 불균형을 초래할 수 있다.
시스템 정책 설계에 흔히 있는 일로서 적절한 값을 찾아내는 것은 마법의 영역이다.

<br/>

### Linux 멀티프로세서 스케줄러

---

리눅스 커뮤니티에는 멀티프로세서 스케줄러를 위한 단일화된 방식이 존재하지 않았다.
O(1), Completely Fair Scheduler(CFS), Brain Fcuk Scheduler(BFS) 세 가지 스케줄러가 등장했다.

O(1)과 CFS는 멀티 큐를, BFS는 단일 큐를 사용하기 때문에 두 방식 모두 실제 시스템에서 성공적으로 사용할 수 있다는 걸 보이고 있다.
물론, 이 스케줄러를 구분하는 다른 많은 분류 기준들이 존재한다.
예를 들어, O(1) 스케줄러는 MLFQ와 유사한 우선순위 기반 스케줄러로서 프로세스의 우선순위를 시간에 따라 변경하여 우선순위가 가장 높은 작업을 선택하여 다양한 목적을 만족시킨다.
특히, 상호작용을 가장 우선시 한다.

반면에 CFS는 보폭 스케줄러에 가까운 결정론적 비례배분 (deterministic proportional share) 방식이다.
BFS는 셋 중에 유일한 단일 큐 방식이며 또한 비례배분 방식이고, Earlist Eligible Virtual Deadline First(EVFDF)라고 알려진 더 복잡한 방식에 기반을 둔다.

리눅스 커널은 2023년까지 사용하던 CFS 스케줄러를 EVFDF 스케줄러로 대체하였다.

<br/>

### 정리

---
- 멀티 프로세서 : 한 컴퓨터에 2개 이상의 CPU가 존재하는 시스템
- 캐시 시간 지역성 : 최근 접근한 데이터는 다시 접근될 가능성이 높다. 
- 캐시 공간 지역성 : 특정 데이터에 접근하면 그 데이터와 가까운 주소의 데이터도 접근될 가능성이 높다.
- 캐시 일관성 문제 : 멀티프로세서 시스템에서 같은 메모리 주소를 다루면 데이터가 일치하지 않을 수 있는 문제
- 버스 스누핑 : 각 CPU 캐시가 공유 메모리 버스를 감시(snoop)하여, 다른 CPU의 메모리 접근이나 수정 정보를 확인하고 자신의 캐시 상태를 업데이트
- 캐시 친화성 : 프로세스가 동일한 CPU에서 반복되어 실행될 때 캐시와 TLB에 상태 정보가 남아 있어 다음 실행 시 더 빠르게 실행되는 현상
- 단일 큐 멀티프로세서 스케줄링 (SQMS) <br/>
  하나의 공유 큐와 다수의 CPU를 사용하는 스케줄링 방식 <br/>
  구현이 단순하지만 동기화 오버헤드(락 경합)가 커 확장성이 낮고 CPU 간 작업 이동이 잦아 캐시 친화성이 낮다.
- 멀티 큐 멀티프로세서 스케줄링 (MQMS) <br/>
  CPU마다 개별 큐를 사용하는 스케줄링 방식 <br/>
  동기화 오버헤드가 줄어들어 확장성이 높고 캐시 친화성이 높다. <br/>
  하지만 워크로드의 불균형이 발생하기에 작업 이주를 통해 균형을 맞추어야 한다.


<br/>

_참고_
- [https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/10-cpu-sched-multi.pdf](https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/10-cpu-sched-multi.pdf)
