---
title: "[운영체제 아주 쉬운 세 가지 이야기 - Concurrency] 32. Concurrency Bugs"
writer: Langerak
date: 2025-10-06 12:00:00 +0800
categories: [Computer Science, Operating System]
tags: [Operating System]
pin: false
math: true
mermaid: true
image:
  path: assets/img/thumbnails/ostep.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: Operating System
---

> 이 글은 제 개인적인 공부를 위해 작성한 글입니다.   
> 틀린 내용이 있을 수 있고, 피드백은 환영합니다.

<br/>

### 개요

---

수년 동안 병행성 관련 오류 해결을 위해 연구자들이 엄청난 시간과 노력을 들였다.
대부분의 초기 연구는 **교착 상태(deadlock)**에 초점이 맞추어져 있었다.
이번 장에서는 좀 더 심도 있게 살펴보기로 한다.
최근의 연구들은 비 교착 상태 버그들을 다르고 있다.
이번 장에서는 실제 코드들을 예로 사용하여 병행성 문제들을 살펴보고 어떤 문제들을 조심해야 하는지 보도록 하겠다.
우리가 이번 장에서 다룰 핵심 문제는 다음과 같다.

그렇다면 일반적인 병행성 관련 오류들은 어떻게 처리하는가.
병행성 버그는 몇 개의 전형적인 패턴을 갖고 있다.
튼튼하고 올바른 병행 코드를 작성하기 위한 가장 첫 단계는 어떤 경우들을 피해야 할지 파악하는 것이다.

<br/>

### 오류의 종류

---

첫 번째 질문은 이것이다.
복잡한 병행 프로그램에서 발생하는 병행성 오류들은 어떤 것들이 있는가?
Lu의 연구에서는 실제 상황에서 어떤 종류의 오류들이 발생하는지 이해하기 위해 그들은 많이 사용되는 병행 프로그램들을 자세히 분석하였다.

이 연구는 대표적인 오픈소스 프로그램 4개인 MySQL, Apache, Mozilla, OpenOffice를 분석하였다.
저자들은 연구에서 이들 코드에서 발견된 병행성 관련 오류에 대해 정량적 분석을 수행하였다.
이 연구를 통해 완성도 높은 코드에서 발생하는 오류의 특성을 쉽게 이해할 수 있다.

아래 그림은 Lu와 그 동룓르이 정리한 오류의 통계이다.
그림에서 보는 바와 같이 총 105개의 오류가 있고 74개의 오류는 교착 상태와 무관한 오류였다.

![img](assets/img/inpost/93.png)

이제 비 교착 상태와 교착 상태들에 대해서 좀 더 자세히 알아보도록 하겠다.
교착 상태 오류들을 다룰 때는 이 분야에서 오랫동안 다루어 온 예방(prevention), 회피(avoidance), 또는 교착 상태를 해결/관리하는 연구들을 논의하겠다.

<br/>

### 비 교착 상태 오류

---

연구 결과를 따르면 비 교착 상태 오류가 병행성 관련 오류의 과반수를 차지한다.
비 교착 상태 오류의 분류 중 대표적인 두 종류의 오류인 **원자성 위반(atomicity violation)** 오류와 **순서 위반(order violation)** 오류를 살펴보자.

<br/>

**원자성 위반 오류**

첫 번째로 만나게 되는 문제는 **원자성 위반**이라고 알려져 있다.
여기 MySQL에서 발견한 간단한 예제가 있다.

```c
Thread 1::
if (thd->proc_info) {
  ...
  fputs(thd->proc_info, ...);
  ...
}

Thread 2::
thd->proc_info = NULL;
```

이 예제에서 thd 자료 구조의 proc_info 필드를 두 개의 다른 쓰레드가 접근한다.
첫 번째 쓰레드는 그 값이 NULL인지 검사하고 값을 출력한다.
두 번째 쓰레드는 값을 NULL로 설정한다.
첫 번째 쓰레드가 검사를 완료한 후 fputs를 호출하기 전에 인터럽트로 인해서 두 번째 쓰레드가 그 사이에 실행될 수가 있다.
두 번째 쓰레드가 실행되면 필드의 값을 NULL로 설정하기 때문에 fputs 함수는 NULL 포인터 역참조를 하게 되어 프로그램은 크래시될 것이다.

Lu 등이 기술한 원자성 위반에 대한 정의는 이렇다.
"다수의 메모리 참조 연산들 간에 있어 예상했던 직렬성(serializability)이 보장되지 않았다. 
즉, 코드의 일부에 원자성이 요구되었으나, 실행 시에 그 원자성이 위반되었다."

지금 예제 코드는 proc_info 필드의 NULL 값 검사와 fputs() 호출 시 proc_info를 인자로 사용하는 동작이 원자적으로 실행되는 것을 가정했다.
이 가정이 깨지면 코드는 의도한 대로 동작하지 않고, 가정은 당연히 성립하지 않는다.

이러한 문제의 수정은 대부분의 경우 아주 단순하게 코드를 수정하면 된다.

락을 추가하여 어느 쓰레드든 proc_info 필드 접근 시, proc_info_lock 이라는 락 변수를 획득토록 한다.
물론, 이 자료 구조를 사용하는 다른 모든 코드들도 락으로 보호해야 한다.

![img](assets/img/inpost/94.png)

<br/>

**순서 위반 오류**

Lu등이 발견한 또 다른 비 교착 상태 오류는 **순서 위반**이다.
아래 간단한 예제가 있다.

```c
Thread 1::
void init() {
  ...
  mThread = PR_CreateThread(mMain, ...);
  ...
}

Thread 2::
void mMain(...) {
  ...
  mState = mThread->State;
  ...
}
```

이 코드에서 쓰레드 2의 코드는 mThread 변수가 이미 초기화되었고 NULL이 아닌 것으로 가정하고 있다.
만약 쓰레드 1이 먼저 실행되지 않았다면 쓰레드 2는 NULL 포인터를 사용하기 때문에 크래시될 것이다.

순서 위반의 정의는 다음과 같다.
"두 개의 메모리 참조 간의 순서가 바뀌었다. 즉, A가 항상 B보다 먼저 실행되어야 하지만 실행 중에 그 순서가 지켜지지 않았다."

이러한 오류를 수정하는 방법은 순서를 강제하는 것이다.
앞에서 자세히 논의했던 것처럼, 이러한 종류의 동기화에는 **컨디션 변수**가 잘 맞는다.
예제 코드는 다음과 같이 재작성 될 수 있다.

![img](assets/img/inpost/95.png)

수정된 코드에서는 mtLock이라는 락, 그에 대한 컨디션 변수 mtCond, 그리고 상태 변수 mtInit을 추가하였다.
초기화 코드가 실행되면 mtInit의 상태를 1로 설정하고 초기화를 완료했다고 시그널을 발생시키낟.
만약 쓰레드 2가 이 시점 전에 실행된다면 상태가 변경되기를 대기한다.
이후에 다시 쓰레드 2가 실행되면 mtInit이 1로 설정되었는지를 검사하고, 올바르게 계속 진ㅐㅇ한다.
mThread 자체를 상태 변수로 사용할 수도 있겠지만 간단함을 위해서 그렇게 하지 않았다.
쓰레드 간의 순서가 문제가 된다면 컨디션 변수 또는 세마포어를 사용하여 해결할 수 있다.

<br/>

**비 교착 상태 오류 : 정리**

연구된 비 교착 상태 오류의 97%는 원자성 또는 순서 위반에 대한 것이었다.
이러한 오류 패턴들을 유의하면 관련 오류들을 좀 더 줄일 수 있다.
더 나아가, 자동화된 코드 검사 도구들이 개발될수록 비 교착 상태 오류들에 초점을 맞추게 될 것이다.
비 교착 상태 오류가 전체 오류 분포에서 많은 비중을 차지하기 때문이다.

하지만, 모든 오류가 예제에서 봤던 것처럼 쉽게 수정될 수 있는 것은 아니다.
어떤 것들은 프로그램 동작에 대한 심도 있는 이해, 방대한 코드에 대한 이해와 자료 구조 재수정이 필요하다.

<br/>

### 교착 상태 오류

---

앞서 다룬 병행성 관련 오류 외에 복잡한 락 프로토콜을 사용하는 다수의 병행 시스템에서 **교착 상태(deadlock)**라는 고전적인 문제가 발생한다.
예를 들어 락 L1을 갖고 있는 쓰레드 1이 또 다른 락 L2를 기다리는 상황에서 불행하게도 락 L2를 갖고 있는 쓰레드 2가 락 L1이 해제되기를 기다리고 있을 때 교착 상태가 발생한다.
교착 상태가 발생할 가능성이 있는 코드를 다음에 나타내었다.

```c
Thread 1::
lock(L1);
lock(L2);

Thread 2::
lock(L2);
lock(L1);
```

이 코드에서는 교착 상태가 발생할 수 있으니 살펴보자.
1. 쓰레드 1이 락 L1을 획득하고 난 후에 문맥 교환이 발생하여 쓰레드 2가 실행한다.
2. 쓰레드 2가 락 L2를 획득하고 락 L1을 획득하려고 시도한다. -> 교착 상태 발생

각 쓰레드가 상대방이 소유하고 있는 락을 대기하고 있기 때문에 누구도 실행할 수 없게 된다.
아래 그림에서 사이클의 존재는 교착 상태 발생 가능성을 의미한다.

![img](assets/img/inpost/96.png)

<br/>

**교착 상태는 왜 발생하는가**

쓰레드 1과 2가 락을 같은 순서로 획득한다면 교착 상태는 절대 발생하지 않는다.
그러면 교착 상태는 왜 발생하는가?

한 가지 이유는 코드가 많아지면서 구성 요소 간에 복잡한 의존성이 발생하기 때문이다.
운영체제를 생각해 보자. 가상 메모리 시스템이 디스크 블럭을 가져오기 위해 파일 시스템을 접근하는 경우가 있다.
파일 시스템은 디스크 블럭을 메모리에 탑재하기 위해 메모리 페이지를 확보해야 하고, 이를 위해 가상 메모리 시스템에 접근한다.
코드 상에서 자연스럽게 존재하는 순환 의존성이 교착 상태를 야기시키는 것을 방지하기 위해서 대형 시스템의 락 사용 전략의 설계는 매우 신중해야 한다.

또 다른 이유는 **캡슐화(encapsulation)**의 성질 때문이다.
소프트웨어 모듈화가 개발을 쉽게 하기 때문에 소프트웨어 개발자들은 상세한 구현 내용은 감추라고 교육 받았다.
하지만, 모듈화와 락은 잘 조화되지 않고 전혀 문제 없어 보이는 인터페이스도 교착 상태를 발생시킨다.
예를 들어, 자바의 Vector 클래스에서 AddAll() 메소드를 생각해보면 이 루틴은 다음과 같은 형식으로 호출될 수 있다.

```java
Vector v1, v2;
v1.AddAll(v2);
```

이 메소드는 멀티 쓰레드에 안전해야 하기 때문에 내부적으로 v1에 더해지는 벡터뿐만 아니라 인자로 전달되는 v2에 대한 락도 같이 획득해야 한다.
이 루틴은 v2의 내용을 v1에 더하기 위해서 임의의 순서로 말한 락들을 획득하는데, 여기서는 v1을 먼저 획득하고 v2를 획득한다고 하자.
어떤 쓰레드가 v2.AddAll(v1)을 거의 동시에 호출하면 교착 상태 발생 가능성이 있다.
이 모든 상황은 호출한 응용 프로그램 모르게 진행된다.

<br/>

**교착 상태 발생 조건**

교착 상태가 발생하기 위한 네 가지 조건이 있다.
여기서 자원은 락으로 생각해도 된다.

1. **상호 배제 (Mutual Exclusion)** : 쓰레드가 자신이 필요로 하는 자원에 대한 독자적인 제어권을 주장한다.
2. **점유 및 대기 (Hold and Wait)** : 쓰레드가 자신에게 할당된 자원을 점유한 채로 획득하고자 하는 다른 자원을 대기한다.
3. **비선점 (No Preemption)** : 자원(락)을 점유하고 있는 쓰레드로부터 자원을 강제적으로 빼앗을 수 없다. 
4. **환형 대기 (Circular Wait)** : 각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의 자원을 갖고 있는 쓰레드들의 순환 고리가 있다.

이 네 조건 중에 하나라도 만족시키 않는다면 교착 상태는 발생하지 않는다.
먼저 교착 상태를 예방할 수 있는 기술들을 먼저 살펴보자.
각 전략들은 위의 조건들이 발생하는 것을 막는다.
그리고 그 전략이 교착 상태를 다루는 방법 중에 하나이다.

<br/>

**교착 상태의 예방**

**환형 대기 (Circular Wait)**

아마도 가장 실용적이고 자주 사용되는 방법이기도 한 교착 상태 예방 기법은 순환 대기가 절대 발생하지 않도록 락 코드를 작성하는 것이다.
가장 간단한 방법은 락 획득을 하는 **전체 순서(total ordering)**를 정하는 것이다.
예를 들어 L1과 L2라는 두 개의 락만이 시스템에 존재하면 L1을 무조건 L2 전에 획득하도록 하면 교착 상태를 피할 수 있다.
이 순서를 따르면 순환 대기는 발생하지 않고 따라서 교착 상태도 발생하지 않는다.

물론, 좀 더 복잡한 시스템의 경우, 두 개 이상의 락이 존재할 것이고 전체 락의 요청 순서를 정의하는 것이 어렵거나 불필요할 수 있다.
교착 상태를 피하기 위해 **부분 순서(partial ordering)**를 제공하는 것이 락 획득 구조를 만드는 데 유용할 것이다.
Linux의 메모리 매핑 코드가 부분 순서를 제공받아 락을 획득하는 방식에 대한 좋은 예다.
소스 코드의 상단의 주석을 보면 열 개의 서로 다른 그룹으로 묶여 있는 락과 그에 대한 획득 순서를 볼 수 있다.

전체 또는 부분 순서를 제공하기 위해서는 세심하게 락 획득 전략을 설계해야 한다.
더 나아가 순서라는 것은 단순히 관례이기 때문에 숙련되지 않은 개발자들이 이 관례를 무시하고 코드를 개발할 경우, 교착 상태가 발생할 수 있다.
마지막으로 락의 순서를 정의하기 위해서는 코드와 다양한 루틴 간의 상호 호출 관계를 이해해야 한다.
작은 실수라 할지라도 교착 상태를 만날 수 있게 된다.

<br/>

**점유 및 대기 (Hold and Wait)**

교착 상태가 발생하는 조건인 점유 및 대기는 원자적으로 모든 락을 단번에 획득하도록 하면 예방할 수 있다.
실제로는 다음과 같은 방법을 사용할 수 있다.

```c
lock(prevention);
lock(L1);
lock(L2);
...
unlock(prevention);
```

이 코드에서는 제일 먼저 prevention 락을 획득하여, 락을 획득하는 과정 중에 쓰레드의 문맥 교환이 발생하는 것을 방지하고,
결과적으로 교착 상태를 발생 가능성을 차단한다.
쓰레드가 락을 획득하려면 전역 prevention 락을 먼저 획득해야 한다.
다른 쓰레드가 L1과 L2를 다른 순서로 획득하려고 한다하더라도 괜찮다.
왜냐하면 그 쓰레드가 prevention 락을 이미 획득한 후에 나머지 락을 요청하기 때문이다.

이 해법은 문제점이 많다.
먼저와 같이 캡슐화와 관련된 사항이다.
필요한 락들을 정확히 파악해야 하고 그 락들을 미리 획득해야 하기 때문이다.
락이 실제 필요할 때 요청하는 것이 아니라 미리 모든 락을 획득하기 때문에 병행성이 저하되는 문제도 있다.

<br/>

**비선점 (No Preemption)**

일반적으로 락을 해제하기 전까지는 락을 보유하고 있는 것으로 보기 때문에 여러 락을 획득하는 것에는 문제의 소지가 있다.
왜냐하면 락을 이미 보유하고 있는 채로 다른 락을 대기하기 때문이다.
많은 쓰레드 라이브러리들은 이러한 상황을 피할 수 있도록 유연한 인터페이스 집합을 제공한다.
trylock() 루틴의 경우 락을 획득하거나 현재 락이 점유된 상태이니 락을 획득하기 원하면 나중에 다시 시도하라는 것을 알리는 -1 값을 리턴한다.

이 인터페이스를 이용하면 교착 상태 가능성이 없고 획득 순서에 영향을 받지 않는 락 획득 방법을 만들 수 있다.

```c
top:
  lock(L1);
  if (trylock(L2) == -1) {
    unlock(L1);
    goto top;
  }
```

다른 쓰레드가 같은 프로토콜을 사용하면서 락을 다른 순서 (L2 먼저 L1 그 다음)로 획득하려고 해도 역시 교착 상태는 발생하지 않는다.
그렇지만 **무한반복(livelock)**이라는 새로운 문제가 생긴다.
두 개의 쓰레드가 이 순서대로 시도하기를 반복하면서 락 획득에 실패하는 것도 가능하다.
두 쓰레드 모두 이 코드를 반복 실행하겠지만 실제 진척이 있는 것은 아니기에 이름대로 무한반복의 상황이다.
무한반복의 문제에 대한 해법도 역시 존재한다.
예를 들면 반복문에 지연 시간을 무작위로 조절하는 것이다.
그러면 경쟁하는 쓰레드 간의 반복 간섭 확률을 줄일 수 있다.

이 해법에 대해 마지막으로 짚고 넘어가야 할 것이 있다.
이 해법은 trylock() 방식의 어려운 부분은 다루지 않고 있다.
첫 번째 문제는 캡슐화이다.
만약 사용하려는 락이 호출되는 루틴 깊숙한 곳에 존재한다면 처음 부분으로 되돌라가도록 구현하는 것이 쉽지 않다.
만약에 코드가 실행 과정에서 L1이 아닌 다른 자원을 획득하였다면, 그 자원 역시 반납해야 한다.
예를 들어 L1 획득 후 코드에서 메모리 영역을 할당하였다면, L2 획득 실패 시에 처음으로 돌아가서 전체 순서를 다시 시작하기 전에 할당받았던 메모리도 같이 반납을 해야 한다.
하지만, 자바 벡터 메소드같은 제한된 경우에만 이러한 접근이 제대로 동작할 것이다.

<br/>

**상호 배제 (Mutual Exclusion)**

마지막 예방 기법은 상호 배제 자체를 없애는 방법이다.
일반적 코드는 모두 임계 영역을 포함하고 있기 때문에 어려운 일이다.

Herlihy는 **대기없는(wait-free)** 자료 구조를 고안했다.
명시적 락이 필요 없는 강력한 하드웨어 명령어를 사용하여 자료 구조를 만들면 된다는 내용이다.

간단한 예제로 다음과 같이 동작하는 Compare-and-Swap 명령어를 가정해 보자.
이 명령은 하드웨어가 지원하는 원자적 명령어를 다룰 때 살펴보았다.

```c
int CompareAndSwap(int *address, int expected, int new) {
  if (*address == expected) {
    *address = new;
    return 1; // 성공
  } 
  return 0; // 실패
}
```

어떤 한 값을 원자적으로 임의의 크기만큼 증가하는 경우를 생각해 보자.

```c
void AtomicIncrement(int *value, int amount) {
  do {
    int old = *value;
  } while (CompareAndSwap(value, old, old + amount) == 0);
}
```

락을 획득하여 값을 갱신한 후에 락을 해제하는 대신, 이 코드에서는 CompareAndSwap 명령어를 사용하여 값에 새로운 값을 갱신하도록 반복적으로 시도한다.
이와 같은 방식을 사용하면 락을 획득할 필요가 없으며 교착 상태가 발생할 수도 없다.
무한 반복은 여전히 발생 가능성이 있기는 하다.

좀 더 복잡한 리스트에 삽입 에제를 살펴보자.
리스트 헤드에 개체를 삽입하는 코드이다.

```c
void Insert(int value) {
  node_t *n = malloc(sizeof(node_t));
  assert(n != NULL);
  n->value = value;
  n->next = head;
  head = n;
}
```

간단한 삽입문을 실행하는 이 코드가 만약 여러 쓰레드에 의해 동시에 호출되면 경쟁 조건이 발생된다.
삽입문 앞뒤에 락의 획득과 해제 코드를 두어 해결하는 방법이 있기는 하다.

```c
void Insert(int value) {
  node_t *n = malloc(sizeof(node_t));
  assert(n != NULL);
  n->value = value;
  lock(listlock);
  n->next = head;
  head = n;
  unlock(listlock);
}
```

이 해법에서는 전형적인 방식으로 락을 사용하고 있다.
단순히 CompareAndSwap 명령어를 사용하여 대기 없이 삽입 명령어를 처리해 보자.
다음과 같은 방법이 있다.

```c
void Insert(int value) {
  node_t *n = malloc(sizeof(node_t));
  assert(n != NULL);
  n->value = value;
  do {
    n->next = head;
  } while (CompareAndSwap(&head, n->next, n) == 0
}
```

이 코드는 next 포인터가 현재의 헤드를 가리키도록 갱신하고 새로 생성된 노드는 리스트의 헤드가 되도록 동작하고 있다.
이 코드를 처리하는 도중 만약 어떤 쓰레드가 새로운 헤드를 성공적으로 추가하였다면, 이 CompareAndSwap는 실패한다.
쓰레드는 삽입 과정을 재시도한다.

유용한 리스트를 만드는 것에는 삽입 동작 이외에 여러 가지가 필요하다.
대기 없는 방식으로 삽입과 삭제 그리고 검색을 할 수 있도록 리스트를 만드는 것은 더욱 쉽지 않다.
만약 이 분야가 흥미로워 보인다면, 대기없는 동기화와 관련된 문서들이 많으니 읽어보기 바란다.

<br/>

**스케줄링으로 교착 상태 회피하기**

어떤 시나리오에서는 교착 상태를 예방하는 대신 **회피**하는 것이 더 유용할 때가 있다.
회피하기 위해서는 실행 중인 여러 쓰레드가 어떤 락을 획득하기 될 것인지에 대해 전반적으로 파악하고 있어야 하며
그것을 바탕으로 쓰레드들을 스케줄링하여 교착 상태가 발생하지 않도록 그때그때 보장한다.

예를 들어 쓰레드 네 개가 프로세서 두 개에서 스케줄링된다고 해 보자.
그리고 추가로 쓰레드 T1이 L1과 L2 락을, T2도 L1과 L2 락을, T3는 L2를 필요로 하고, T4는 락을 필요로 하지 않는다고 가정하자.
쓰레드들의 락 요청에 대한 정보를 다음과 같이 표로 정리 해 볼 수 있다.

![img](assets/img/inpost/97.png)

똑똑한 스케줄러라면 T1과 T2가 동시에 실행만 하지 않는다면 교착 상태가 절대로 발생하지 않도록 할 수 있다.
그와 같이 스케줄링된 예는 다음과 같다.

![img](assets/img/inpost/98.png)

T3와 T1 또는 T3와 T2끼리는 겹쳐서 실행이 되도 괜찮다.
T3가 절대로 교착 상태를 유발하지 않는 이유는 단 하나의 락만 필요하기 때문이다.

또 다른 예를 살펴보자.
이번에는 다음의 표에서 나타난 것과 같이 동일한 자원에 대해 경쟁이 심해졌다고 해 보자.

![img](assets/img/inpost/99.png)

쓰레드 T1, T2, 그리고 T3가 실행 중 어느 시점에 모두 L1과 L2 락을 획득하는 경우를 예로 들어보자.
그런 경우에 교착 상태가 절대로 발생하지 않도록 하는 가능한 스케줄링은 다음과 같다.

![img](assets/img/inpost/100.png)

보는 바와 같이 정적 스케줄링은 T1, T2, T3가 모두 한 프로세서에서 실행되도록 보수적인 방법을 택하기 때문에 전체 작업이 끝나기까지 상당히 오랜 시간이 소요된다.
병행이 가능할 수도 있겠지만, 교착 상태가 발생할 수 있기 때문에 그렇게 할 수 없으며, 어쩔 수 없이 성능 하락을 수반한다.

<br/>

**발견 및 복구**

마지막 전략은 교착 상태 발생을 허용하고, 교착 상태를 발견하면 복구토록 하는 방법이다.
예를 들어 운영체제가 일 년에 한 번 멈춘다고 했을 때 재부팅을 하고 기분 좋게 다시 작업을 처리하는 식이다.
교착 상태가 아주 가끔 발생한다면 이런 방법도 꽤 유용하다.

많은 데이터베이스 시스템들이 교착 상태를 발견하고 회복하는 기술을 사용한다.
교착 상태 발견은 주기적으로 실행되며 자원 할당 그래프를 그려서 사이클이 생겼는지를 검사한다.
사이클이 발생하는 경우 시스템은 재부팅되어야 한다.
자료 구조에 대한 복잡한 복구가 필요할 경우, 사람이 직접 복구 작업을 수행할 수도 있다.

데이터베이스의 병행성, 교착 상태, 그리고 관련 문제들에 대한 상세한 내용은 다른 문헌에서 찾아 볼 수 있다.

<br/>

### 요약

---

**병행성 버그 Concurrency Bugs** : 다중 쓰레드 환경에서 발생하는 오류로 크게 교착 상태와 비 교착 상태 버그로 나뉜다.

**비 교착 상태 오류 Non-deadlock Bugs**
- 원자성 위반 Atomicity Violation : 원자적으로 실행되어야 할 코드 영역이 다른 스레드에 의해 중단될 때 발생. 락을 사용하여 임계 영역을 보호하여 해결한다.
- 순서 위반 Order Violation : 두 메모리 접근이 의도한 순서와 다르게 실행될 때 발생. 컨디션 변수를 사용하여 스레드 간의 실행 순서를 강제하여 해결한다.

**교착 상태 오류 Deadlock Bugs** : 둘 이상의 쓰레드가 상대방이 가진 자원을 기다리며 영원히 멈추는 상태 

**교착 상태 발생 조건 4가지** : 이 네 가지 조건이 모두 만족될 때 교착 상태가 발생할 수 있다.
1. 상호 배제 Mutual Exclusion : 자원은 한 번에 하나의 스레드만 사용할 수 있다.
2. 점유 및 대기 Hold and Wait : 자원을 가진 상태에서 다른 자원을 기다린다.
3. 비선점 No Preemption : 다른 스레드의 자원을 강제로 빼앗을 수 없다.
4. 환형 대기 Circular Wait : 스레드들이 서로가 가진 자원을 기다린다.

**교착 상태 처리 전략**
1. 예방 Prevention : 교착 상태 발생 조건 중 하나를 제거하여 교착 상태가 발생하지 않도록 한다.
   - 환형 대기 예방 : 모든 락에 전체 순서(total ordering)를 부여하여 순서대로만 획득하게 한다.
   - 점유 및 대기 예방 : 필요한 모든 락을 원자적으로 한 번에 획득하게 한다.
   - 비선점 방지 : trylock()을 사용하여 락 획득 실패 시 이미 획득한 락을 해제하고 다시 시도하게 한다. 무한반복(livelock) 가능성이 있다.
   - 상호 배제 방지 : 대기 없는(wait-free) 자료 구조를 Compare-and-Swap 같은 원자적 명령어를 사용하여 구현한다.

2. 회피 Avoidance : 스케줄러가 스레드들의 자원 요구량을 미리 파악하여 교착 상태를 유발하지 않는 안전한 순서로 스케줄링한다.
3. 발견 및 복구 Detection and Recovery : 교착 상태 발생을 허용하고, 주기적으로 자원 할당 그래프에서 사이클을 탐지하여 시스템 재부팅 등으로 복구한다.

<br/>

_참고_

- [https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/32_threads-bugs.pdf](https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/32_threads-bugs.pdf)
